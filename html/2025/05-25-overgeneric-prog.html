<!DOCTYPE html>

<html lang="ru">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Сверхобобщение</title>

  <link rel="stylesheet" type="text/css" href="../main.css"/>
</head>

<body>
<h2>Особенности сверхобобщённого программирования</h2>

<p>Продолжение темы, затронутой в <a href='05-13-generic-programming.html'>предыдущей заметке</a>, посвящённой проблемам сверхобобщённого программирования.</p>

<!--more-->

<style> p,ul{hyphens: auto; text-align:justify;} ul{margin-left: 1em !important;padding-left: 1em !important;}</style>

<br/><br/>

<h3>Общие суждения</h3>

<ul>
<li>Обобщения строятся на единообразии используемого
  <ul>
  <li>Единообразие достигается в тождестве или в подобии
    <ul>
    <li>Тождество может достигаться
      <ul>
      <li>за счёт использования более широкого понятия (усложение модели)

      <li>или за счёт избавления от второстепенных деталей, то есть абстракции (упрощение модели)

      <ul><li>Абстракция в рамках задачи самостоятельна и не требует связи с исходной более сложной моделью</ul></ul>

    <li>Подобие достигается за счёт косвенности через посредника, единообразно представляющего разные вещи. Из-за частичного сходства многие программисты путают это с абстрагированием
      <ul><li>В отличии от абстракции косвенность требует связи посредника с исходной моделью

      <li>Косвенность может как сохраняться во время исполнения, так и устраняться при подготовке
        
      <li>Можно выделить два вида посредничества: П0 — обеспечивающих одинаковое поведение (обычно приблизительно) и П1 — рассчитанных на одинаковую стыковку элементов с разным поведением
        <ul>
        <li>П0 — платформы; нужны для обобщения условий, в которых работает код, для обеспечения его переносимости
        <li>П1 — конструкторы; нужны как обобщённый способ создания разного поведения
        </ul>
      </ul>
    </ul>

  <li>Желательно выделение только естественного единообразия. Приведение недостаточно совместимых вещей к единому представлению должно рассматриваться как ошибка

  <li>Когда выбор стоит не столько между общим и частным, сколько между общими частностями и разрозненными частностями, не стоит отказываться от частного в пользу общего, если нет большой уверенности, что общая частность сохранится. Общепринятые частности не всегда, но часто относятся к такому случаю

  <li>Инструмент должен стремиться к унификации приёмов, предлагая в большей степени дополняющие друг друга средства, чем соперничающие между собой

  <li>Инструмент должен предлагать обобщения на едином уровне представления. Пример нарушения — внутристроковые языки, макросы препроцессора и синтаксические макросы против средств основного языка

  <li>Не должно быть драматичной разницы между исполнением (runtime) и трансляцией (compiletime), потому что трансляция — это лишь исполнение компилятора. Вещи, необходимые компилятору, могут понадобиться и другим программам

  <li>Эффективность крайне важна для обобщений. Чем она выше, тем потенциально больше возможность переиспользования. Обобщение не может считаться полноценным, если оно ограничено в применение из-за неэффективности
    <ul><li>Специализация является важным способом повышения эффективности решений, сформулированных обобщённо
      <ul><li>Лучше, если специализация будет доступна и во время исполнения</ul></ul>

  <li>Высокая контролируемость важна, так как из-за повышенного переиспользования сверхобобщённый код может обрасти бо́льшим количеством связей, что может привести к усложнению их понимания и использования без дополнительной помощи. Инструмент должен предоставлять возможность строгих указаний того, что ожидается от парамтров

  <li>Строгая статическая типизация и ограничения доступа, защищая от неправильного использования, также создают препятствия для ряда обобщений.
    <ul>
    <li>Проще всего создать возможность эффективного переиспользования в безтиповом языке, но исчезает защита от ошибок и подсказки по правильному использованию

    <li>Строгая динамическая типизация позволяет добиться схожей гибкости при сохранении защиты от ошибок во время исполнения, но теряются эффективность выполнения и статическая защита

    <li>Сверхобобщённая же статическая типизация, сохраняя эффективность и наилучшую защиту, оказывается сверхсложной как для воплощения, так и для использования, то есть защищает не только от ошибок, но и от правильного кода
    
    <li>Статическая типизация может служить не только дополнительным препятствием для переиспользования, но и наоборот служить основой для него, когда типы служат предметом рассмотрения кода

    <li>Поскольку однозначно хорошее решение неизвестно, то прагматичный язык вынужден предоставлять компромиссное решение, сочетая эти возможности

    <li>Классификация — это способ выделения подобия в рамках строгой типизации
      <ul>
      <li>Правильная классификация не требует общего происхождения, а основана только на нахождении общих свойств, которые к тому же могут быть выражены по-разному. Одно и то же может входить в разные классы и даже в один класс входить по-разному в зависимости от рассмотрения

      <li>Переменные подклассов применимы на чтение там, где ожидаются переменные класса, но в общем случае не применимы  на запись, хотя при динамическом контроле подстановка допустима для случая, когда записываемое значение динамически принадлежит соответствующему подклассу. Инструмент должен уметь различать эти особенности, чтобы не мешать правильному переиспользованию
      </ul>
    </ul>
  </ul>

  <li>Обобщение нужно но не только для одновременно существующих вещей, но и для разнесённых во времени. Инструмент должен учитывать развитие кода и давать возможность гладкой эволюции. Переиспользование не должно препятствовать последующему внесению улучшений в код, в том числе, и для большего обобщения

  <li>Общая среда исполнения не должна выстраивать традиционных преград для взаимодействия кода. Это приводит к созданию частично похожих, но несовместимых систем кодирования по разные стороны этих преград, а также допослнительных средств для их преодоления

  <li>Частный код (proprietary) создаёт дополнительное препятствие для обобщённого кода через усложнение переиспользования

  <li>Платформа с торчащим наружу машинным представлением кода, как и распространение кода в машинном виде, тоже служат препятствиями для переиспользования и обобщения
</ul>

<br/>

<h3>Особенности языка для сверхобобщённого программирования</h3>
<p>Эти особенности являются частными следствиями общих суждений.</p>
<ul>
<li>Данные и их тип связаны, но остаются отдельными сущностями, устраняя таким образом одно из препятствий для обобщения при сохранении безопасности данных
  <ul>
  <li>Данные характеризуются ёмкостью
  <li>Тип — это способ рассмотрения данных, не зависящий напрямую от ёмкости данных
  <li>В случае чтения ёмкость данных может быть ниже ёмкости типа (вплоть до 0), а в случае записи — выше
  </ul>

<li>Тип — это тоже данные, но всегда неизменяемые. Можно создать новый тип, но нельзя изменить старый
  <ul><li>Статический тип, не учавствующий в рефлексии времени исполнения, не требует своего явного присутствия в памяти после трансляции</ul>
  
<li>Все типы являются обобщёнными в том смысле, что любые данные с рассмотрением, соответствующим внешнему описанию типа, могут рассматриваться как данные этого типа

<li>Новый тип для тех же данных может быть собран как надстройка над старым типом без необходимости менять что-либо в самих данных

<li>Подпрограмма принимает, фактически, два параметра — тип и данные. Они способны представлять любой набор обычных параметров. Синтаксически это не заметно

<li>Статическое и динамическое обобщения делаются единообразно
  <ul>
    <li>Для статического обобщения параметр-тип является постоянной, а для динамического — переменной
    <li>Значение для переменной-типа может быть получено не только из набора предопределённых в коде значений, но и собрано во время исполнения по входным данным
    <li>Динамически полученный тип можно привести к статически заданному типу, если тот соответствует его требованиям
    </ul>

<li>Обобщённое понятие массива
  <ul>
  <li>Возможна длина 0
  <li>Срез массива тоже является массивом уменьшенной длины
  <li>Размерность массива можно приводить к другому значению, сохраняя общую ёмкость
    <ul>
    <li>В частности, любой тип может быть представлен как массив этого типа единичной длины</ul>
    <li>Часть записи, подряд содержащая однородные элементы, тоже может рассматриваться как массив соответствующей длины
      <ul><li>Так как все типы являются обобщёнными, то всегда можно выделить уровень обобщения, на котором элементы будут однородными. Впрочем, такое приведение может быть ресурсоёмким</ul>
    </ul>

<li>Числовые типы
  <ul>
  <li>Типы без знака являются лишь сокращением для обозначения переменных типов со знаком с указанием недопустимости отрицательных значений
    <ul><li>Ёмкость типов без знака равна ёмкости неотрицательных значений соответствующих им типов со знаком</ul>
  <li>Ёмкость положительных и отрицательных значений у типов со знаком одинакова
    <ul><li>Значение по модулю и смена знака гарантированно происходят без переполнения отрезка значений операнда</ul>
  <li>Без знака могут быть как целые, так и дроби
  <li>Признаки переполнения верхней и нижней границ, а также неопределённость могут быть частью типа чисел (целых тоже), но не являются свойством по умолчанию (для дробей тоже)
    <ul>
      <li>Для целых специальные значения вычитаются из отрезка значений типа-основы, для дробей зарезервированы в любом случае
      <li>Признаки переполнения не следует трактовать как бесконечности
        <ul>
        <li>При умножении на 0 результатом будет 0
        <li>Если значение вычитается из самого себя, когда возможно отследить, что оно действительно пришло из одного источника, то результатом будет не неопределённость, а 0
        <li>Аналогично для деления на само себя — будет 1
        </ul>
    </ul>
  <li>В промежуточных данных (переменных подпрограмм) допустимы только типы чисел со знаком
  <li>Вычисления производятся в более ёмком типе относительно типа операндов
    <ul><li>Результат может сохраняться без дополнительных преобразований в типе, равном максимально ёмкому типу операндов, но с проверкой возможности переполнения</ul>
  </ul>

<li>Логический тип и множество
  <ul><li>Булев тип является множеством единичной ёмкости только для 0</ul>

<li>Место хранения данных
  <ul><li>С точки зрения использования нет различения между статическим (в том числе локально) и динамически размещёнными переменными. Но есть различение по владению данными — то, что косвенно задаётся способом размещения
    <li>Нет разницы и между оперативной памятью и памятью <u>внутреннего</u> накопителя. Оперативную память можно рассматривать как один из уровней кэша, но желательно не на уровне ОС, а на уровне библиотеки. Тоже самое касается и обычного кэша, но на данном уровне развития ПО это невозможно или слишком сложно
  </ul>

<li>Утверждения (assertion), применённые к формальным параметрам, могут быть переиспользованы как мягкие проверки (if) для случаев, когда фактические параметры могут не соответствовать этим утверждениям

</ul>

</body>
</html>
