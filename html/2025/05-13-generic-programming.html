<!DOCTYPE html>

<html lang="ru">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Сверхобобщение</title>

  <link rel="stylesheet" type="text/css" href="../main.css"/>
</head>

<body>
<h2>Проблемы сверхобобщённого программирования</h2>

<div class="separator" style="clear: both;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiFlrH9-6T0lDVslXxf84b7Y_VX385BXALmXv_KtDG-fSbOQvIrlpsQQ7KDfdE3JylT4oSDUFyoTi1b1Qa5IM06saPujs_GdYColJFUju3r6xe3l8-g04uZZh8_p8KU2az8AvoBQGkrmeBf0PazgUO6YZaTmY8oJNieQOcgw2K_KCSKNHgvKrafyKrCYDmJ/s1536/20250523_1323_%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B6%D0%B8%D0%B2%D0%BE%D1%82%D0%BD%D1%8B%D1%85_simple_compose_01jvyam9d1faa80xsqf27xerc1.png" style="display: block; padding: 0 0.5em; text-align: center; clear: right; float: right;"><img alt="" border="0" width="400" data-original-height="1024" data-original-width="1536" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiFlrH9-6T0lDVslXxf84b7Y_VX385BXALmXv_KtDG-fSbOQvIrlpsQQ7KDfdE3JylT4oSDUFyoTi1b1Qa5IM06saPujs_GdYColJFUju3r6xe3l8-g04uZZh8_p8KU2az8AvoBQGkrmeBf0PazgUO6YZaTmY8oJNieQOcgw2K_KCSKNHgvKrafyKrCYDmJ/s400/20250523_1323_%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B6%D0%B8%D0%B2%D0%BE%D1%82%D0%BD%D1%8B%D1%85_simple_compose_01jvyam9d1faa80xsqf27xerc1.png"/></a></div>

<style>p { hyphens: auto; text-align:justify; }</style>
<p>В определённой степени программисты всегда пишут обобщённо, ведь программы обычно решают класс задач, а не строго одну задачу, например, решение не конкретного уравнения, а множества уравнений. Кроме того, самые обобщённые коды уже созданы много раз — это алгоритмически полные исполнители. Параметризуя их конфигурацией, в данном случае называемой программой, можно добиться исполнения всего, что возможно в принципе. Но программистам этого мало, и они хотят писать всё более обобщённо, вовлекая в это всё больше деталей на разных уровнях. Такой код следовало бы называть сверхобобщённым, потому что он обобщает обобщения. Этот подход заманчив, ведь он потенциально позволяет меньшими усилиями решать больше задач. Но <b>главная проблема</b> такого кода в том, что:</p>

<!--more-->

<ul>
  <li>Его сложней создавать
  <li>Его сложней использовать в частных применениях
  <li>Сложность возрастает ещё больше при необходимости высокой правильности или эффективности
</ul>

<p>Поэтому, чтобы написание и использование более сложного кода было оправданно, необходимо, чтобы он <u>хорошо</u> решал довольно большое количество задач. Но предвидеть, что именно нужно было обобщить так, чтобы это было полезно, тоже довольно сложно. Поэтому создаётся много сверхобобщенного кода, который решает обратную задачу — вместо того, чтобы уменьшить количество усилий, их только увеличивает.</p>

<p>Часто, чтобы найти хорошее обобщение, нужно сначала создать несколько более частных решений, и только затем увидеть общие потребности. Это может быть отправной точкой для создания обобщённого кода, но если появление новых задач такого рода оказывается под вопросом, то поддержка уже существующих частных решений может оказаться более выгодным, чем попытка их объединения.</p>

<p><b>Второй по значимости проблемой</b> для сверхобобщённого кода являются общие сложности переиспользования кода — того, что могло бы повысить полезность создания обобщений. Сложно находить тот код, который точно можно было использовать для своих задач без изменений. Найденный код тоже требует изучения, потому нередко оказывается, что написание нового кода для проекта, может быть менее накладным, чем совокупные затраты по поиску и изучению кода для переиспользования.</p>

<p>Переиспользование интересным образом входит в противоречие с возможностью создания обобщённого кода. Сразу создать обобщённый код сложно и куда проще доработать его до этого состояния под влиянием всё большего охвата решений схожих задач. Но уже существующие решения требуют неизменности используемого кода. Создание независимой новой версии с потенциально более высокой переиспользуемостью, отчасти, наоборот, плодит частности.</p>

<p>Помимо этого, есть ещё проблема влияния на разработчика. Сверхобобщённое программирование приводит к дополнительному разделению ролей, и со стороны пользователей заготовок провоцирует шаблонное мышление, что препятствует решению задач, требующих более гибких подходов. Порой, решение подгоняется под привычные шаблоны даже в тех случаях, где оригинальный подход оказывается лучше во всех проявлениях, в том числе, проще для человека. Очень сложно одновременно развивать и способность использовать шаблоны, и мыслить более свободно.</p>

<p>Эти проблемы сверхобобщённого кода выглядят как фундаментальные, и для их хорошего решения сложно предложить что-то для человеческих программистов.</p>

<p>Но есть ещё <b>третья по значимости проблема</b> для сверхобобщённого кода, для которой, пожалуй, кое-что предложить можно. Это особенности языков программирования. В одних языках не хватает средств для обобщения, в других языках они добавлены эволюционно, что во многом ухудшает многие свойства таких средств. В первую очередь, не хватает гармонии, что усложняет их использование и делает почти невозможным некоторые виды обобщений. Кроме того, как сложный предмет, обобщение в язык могло быть включено полу-абсурдным способом и от этого страдает существенная доля используемых языков.</p>

<p>Чтобы претендовать на успешное достижение своей цели, язык сверхобобщённого программирования, как и инфраструктура на его основе, должны проектироваться таковыми с самого начала. Подумать над особенностями такого языка предлагаю в <a href="05-25-overgeneric-prog.html">следующей заметке</a>.</p>

</body>
</html>
